from fastapi import FastAPI, UploadFile, Path
from uuid import uuid4
from .utils.file import save_to_disk
from .db.collections.files import files_collection, FileSchema
from .queue.q import q
from .queue.workers import process_file
from bson import ObjectId

app = FastAPI()

@app.get("/")
def hello():
    return {"status": "container is healthy and fit"}

@app.get("/{id}")
async def get_file_by_id(id: str = Path(...,description="ID of the file")):
    db_file = await files_collection.find_one(
        {
            "_id" : ObjectId(id)
        }
    )

    print(db_file)

    return {
        "_id" : str(db_file["_id"]),
        "name": db_file["name"],
        "status": db_file["status"],
        "result": db_file["result"] if "result" in db_file else None,
    }

@app.post("/upload")
async def upload_file(file: UploadFile):

    # id = uuid4()
    # user upload file before saving into disk save status in db as saving
    db_file = await files_collection.insert_one(
        document = FileSchema(
            name = file.filename,
            status = 'saving'
        )
    )


    # determine the path for the file user upload using id generated by mongodb
    file_path = f"/mnt/uploads/{str(db_file.inserted_id)}/{file.filename}"

    # saving into disk
    await save_to_disk(file = await file.read() , path = file_path)

    #pushed to queue
    q.enqueue(process_file,str(db_file.inserted_id),file_path)

    #updating status in mongodb
    await files_collection.update_one(
        {"_id": db_file.inserted_id},
        {
            "$set":{
                "status":"queued"
            }
        }
    )


    return {"file_id": str(db_file.inserted_id)}


